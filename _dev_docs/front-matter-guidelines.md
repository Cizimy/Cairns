# Front Matter 記述ガイドライン

## 1. はじめに

### 1.1. このガイドラインの目的と対象読者

#### 目的

このガイドラインは、Cairns プロジェクトにおける Markdown ドキュメントの品質、一貫性、および自動処理（検証、インデックス作成、ガバナンス等）を担保するために、ドキュメントのメタデータである **Front Matter** の記述方法を標準化することを目的とします。

主な目的は以下の通りです。

* 開発者やドキュメントコントリビューターが、Cairns プロジェクトの要件（JSON Schema 定義、カスタム検証ルール、命名規則、フォルダ構成など）に準拠し、正確かつ効果的に Front Matter を記述できるよう支援します。
* プロジェクト全体の目標である AI (RAG) 活用促進や開発者体験 (DX) 向上との整合性を確保し、将来のプロジェクト進化（LLM連携深化、ガバナンス強化）に対応できる記述基盤を確立します。
* [`template.md`](templates/template.md) や VSCode 拡張機能だけではカバーしきれない詳細なルール、ベストプラクティス、各フィールドの意図、そして **ローカルでのカスタム検証の重要性** について解説します。

#### 対象読者

このガイドラインは、以下の方々を対象としています。

* Cairns プロジェクトに関わるすべてのドキュメント作成者、編集者、レビュー担当者。
* プロジェクトの技術ツール（CI/CD、検証スクリプト、RAG Indexer、静的サイトジェネレーター等）の開発・保守担当者。
* プロジェクトのアーキテクチャ、情報管理、ガバナンスに関心を持つステークホルダー。

---

### 1.2. Front Matter の重要性 (一貫性、自動化、AI活用、ガバナンス)

Cairns プロジェクトにおいて、ドキュメントの Front Matter は単なるメタデータではなく、プロジェクト全体の品質と効率性を支える基盤です。その重要性は、以下の4つの観点から理解できます。

* **一貫性の担保 (Consistency):**
    * リポジトリ内のすべてのドキュメントが共通の構造と語彙を持つことを保証し、**開発者の学習コストを削減し、ドキュメント間の関連性の理解を容易にします。**
    * `id` とファイル名の一致、`layer` とフォルダ構造の整合性など、命名規則 ([`naming-conventions.md`](naming-conventions.md) 参照) やフォルダ構成 ([`folder-structure.md`](folder-structure.md) 参照) との連携により、体系的な知識管理を実現し、**ツールによる自動処理の信頼性を向上させます。**
    * [`template.md`](templates/template.md) と本ガイドラインの併用により、記述の標準化を促進します。

* **自動化の基盤 (Automation):**
    * CI/CD パイプラインにおける自動検証（スキーマ準拠、カスタムルールに基づく整合性チェック：ID一意性・命名規則、参照整合性 (リンク切れ検知)、時間整合性、**`core_principles` 記述ルール** 等）を可能にし、ドキュメントの品質を維持し、**ヒューマンエラーを削減します。** ([`devtools-list.md`](devtools-list.md), [`document-map.md`](document-map.md) 参照)
    * 静的サイトジェネレーター (SSG) によるドキュメントサイトの自動構築（ナビゲーション生成、関連ドキュメント表示、メタデータ表示など）を支援し、**情報アクセシビリティを高めます。** ([`devtools-list.md`](devtools-list.md) 参照)

* **AI活用 (RAG) の鍵 (AI Enablement):**
    * `abstract`, `summary`, `keywords`, `core_principles`, `relationships`, `applicable_contexts`, `target_audience` などのフィールドに正確かつ質の高い情報を記述することで、AI（特に RAG システム）によるドキュメントの検索精度、要約生成、関連知識の抽出能力を大幅に向上させ、**開発者の生産性向上や AI エージェントのタスク遂行能力向上に貢献します。** ([`document-map.md`](document-map.md) 参照)
    * 将来の高度な LLM 連携 (例: `llm_usage_hints` の活用) のための基礎となり、**よりインテリジェントなドキュメント活用を実現します。** ([`action-plan.md`](action-plan.md) 参照)

* **ガバナンスとライフサイクル管理 (Governance):**
    * `status`, `version`, `authors`, `owner`, `last_updated`, `created_at`, `review_cycle_days`, `expires_at`, `license`, `checksum`, `signed_by` などのフィールドを通じて、ドキュメントの鮮度、信頼性、責任体制、承認状態を管理・追跡可能にし、**ドキュメントのトレーサビリティと信頼性を確保します。**
    * プロジェクト全体のガバナンスプロセス (例: 承認フロー、定期レビュー) の運用を支え、**コンプライアンス遵守や品質基準の維持に貢献します。** (`l0-governance.md` (作成中) 参照)

---

### 1.3. 関連ドキュメントへのリンク

本ガイドラインを理解し、効果的に活用するために、以下の関連ドキュメントを参照することを強く推奨します。

* **JSON Schema:**
    * [`schema/cairns-front-matter.schema.json`](../../schema/cairns-front-matter.schema.json): Front Matter の正確な構造、型、必須項目、許容値などを定義する公式な定義。本ガイドラインの記述の根拠となります。
    * [`schema/patterns.schema.json`](../../schema/patterns.schema.json): ID やパスなどに使われる正規表現パターンを定義。特定のフィールドのフォーマットを確認する際に参照。
    * (その他: [`schema/common-defs.schema.json`](../../schema/common-defs.schema.json), [`schema/content-defs.schema.json`](../../schema/content-defs.schema.json), [`schema/metadata-defs.schema.json`](../../schema/metadata-defs.schema.json)): より詳細な共通定義や特定フィールド群の定義。

* **情報アーキテクチャと規約:**
    * [`_dev_docs/l0-cairns-overview.md`](../l0-cairns-overview.md): Cairns プロジェクト全体の目的、構造、基本方針を解説。本ガイドラインを読む上での前提知識として役立ちます。 *(追加)*
    * [`_dev_docs/document-map.md`](../document-map.md): Cairns プロジェクト全体のドキュメント体系 (L0-L5 レイヤー構造)、各ドキュメントの目的、CI で検証される項目などを定義。`layer` や `core_principles` の記述ルールなどを理解するために参照。
    * [`_dev_docs/naming-conventions.md`](../naming-conventions.md): フォルダ名、ファイル名、ドキュメント ID (`id`)、原則 ID (`principle_id`) などの命名規則を定義。特に **`id` とファイル名の一致ルール** は厳守事項です。
    * [`_dev_docs/folder-structure.md`](../folder-structure.md): リポジトリ全体のフォルダ構成を定義。特に `snippets/`, `media/` 配下へのリソース配置とパス構造のルールを参照。

* **テンプレートとツール:**
    * [`_dev_docs/templates/template.md`](../templates/template.md): 新規ドキュメント作成時に使用する基本テンプレート。主要なフィールドと簡単な説明が含まれます。
    * [`_dev_docs/devtools-list.md`](../devtools-list.md): プロジェクトで使用される Linter、Validator、CI ツールなどのリスト。特に、**ローカルでのカスタム検証スクリプトの必要性** とその背景 (VSCode 拡張機能の限界等) を理解するために参照。

* **プロジェクト管理と運用:**
    * `_dev_docs/l0-glossary.md` (**作成中：完成次第参照必須**): プロジェクト内で使用される共通の専門用語や略語の定義。
    * `_dev_docs/l0-contribution-guide.md` (**作成中：完成次第参照必須**): ドキュメントの作成・更新プロセス、レビュー手順など、貢献方法の詳細。
    * `_dev_docs/l0-governance.md` (**作成中：完成次第参照必須**): ドキュメントのライフサイクル管理、承認プロセス、`status` 変更に伴う要件 (`checksum`, `signed_by` 等) の詳細。
    * [`_dev_docs/action-plan.md`](../action-plan.md): プロジェクト全体の開発計画。AI連携 (RAG) やガバナンス強化など、将来的な方向性を理解する上で参考になります。

---

## 2. 【最重要】ローカル検証ガイド (DX向上)

### 2.1. なぜローカル検証が必要か

このセクションでは、Cairns プロジェクトにおいて、なぜ CI/CD パイプラインだけに頼るのではなく、開発者自身のローカル環境で Front Matter の検証を行うことが**非常に重要**なのか、その理由を明確に解説します。

ローカル検証は、単なる推奨プラクティスではなく、プロジェクトの品質維持と開発効率向上のために**必須**のプロセスと位置づけられています。その必要性を理解することで、後続セクションで解説する具体的なセットアップや実行手順の意義がより明確になるでしょう。

---

#### 2.1.1. スキーマだけでは不十分な理由 (Cairns 固有ルール)

Cairns プロジェクトでは、Front Matter の記述ルールを定義するために JSON Schema ([`schema/cairns-front-matter.schema.json`](../../schema/cairns-front-matter.schema.json) 参照) を活用しています。JSON Schema は、フィールドの有無、データ型、必須/任意、許容される値 (enum)、文字列パターンなどを定義するための強力なツールであり、Draft 2020-12 の高度な機能（条件付き必須項目、レイヤーに応じた必須項目など）も利用しています。

しかし、JSON Schema による検証だけでは、Cairns プロジェクトが要求する全ての品質基準を満たすことはできません。なぜなら、スキーマ定義は主に**構造的な妥当性**を保証するものであり、プロジェクト固有の**意味論的な整合性**や、ファイルシステムなどの**外部リソースとの依存関係**までは検証できないためです (この点はスキーマファイル自身のコメントにも記載されています)。

具体的には、以下のような **Cairns 固有のルール** は、JSON Schema の範囲を超えており、カスタム検証スクリプト ([`devtools-list.md`](../devtools-list.md) の A6 参照) によるチェックが必要です。これらのルールは、[`document-map.md`](../document-map.md) で定義されている CI 検証項目の一部にも対応しています。これらのルールに違反すると、リンク切れや情報の不整合、CI エラーなど、様々な問題を引き起こす可能性があります。

  * **ID とファイル名の一致:**

      * Front Matter の `id` フィールドの値は、その Markdown ファイルの名前 (拡張子を除く) と完全に一致する必要があります ([`naming-conventions.md`](../naming-conventions.md) 参照)。
      * スキーマは `id` の**形式** (例: `^[a-z0-9\\-]+$`) を検証できますが、ファイルシステム上の**ファイル名との照合**はできません。
      * *(違反時の影響例: ツールによるドキュメント間の自動リンク生成や参照解決が失敗したり、開発者が手動で関連ファイルを探す際に混乱が生じます。)*

  * **参照整合性 (リンク切れチェック):**

      * `snippet_refs` ([`schema/patterns.schema.json#pattern-snippetPath`](../../schema/patterns.schema.json) 参照) で指定されたスニペットファイルが、**推奨されるパス形式 (`./snippets/<doc-id>/<principle-id>.code.md`) に従っており、かつ実際に存在するか**。
      * `media[].path` で指定された画像などのメディアファイルが実際に存在するか。
      * `relationships[].to`, `references[].doc_id`, `deprecation_info` などで参照される他の Cairns ドキュメント ID や原則 ID (`docId#principleId` 形式) がリポジトリ内に実際に存在するか。
      * `detail_ref` や `core_principles[].detail_ref` などで指定された Markdown 本文中のアンカー (`#anchor-name`) が実際に存在するか。
      * スキーマは参照先のパスや ID の**形式**を検証できますが、その**実在性**までは保証できません。
      * *(違反時の影響例: ドキュメント内にリンク切れが発生したり、存在しないコードスニペットや画像を参照しようとしてエラーとなり、読者の理解を妨げ、ドキュメントの信頼性を損ないます。)*

  * **時間整合性:**

      * `created_at`, `last_updated`, `expires_at` の各フィールド間の時間的な前後関係 (`created_at <= last_updated <= expires_at`) が保たれているか。
      * スキーマは各々が有効な日時形式であることは検証しますが、フィールド間の**値の比較**はできません。
      * *(違反時の影響例: ドキュメントの更新履歴や有効期限の管理に矛盾が生じ、ステータス管理やレビュープロセスの自動化に支障をきたす可能性があります。)*

  * **構造整合性 (例: `core_principles`):**

      * [`document-map.md`](../document-map.md) で定義されているように、ドキュメントの `layer` に応じて `core_principles` の記述方法に関するルールがあります (例: `L2` では複数の原則定義が可能だが、`L3` 以上では原則としてドキュメント全体を表す単一の `<doc-id>-main` という ID の原則を定義するなど)。
      * スキーマの `if/then` を使ってレイヤーに応じた `core_principles` フィールド自体の必須化は行っていますが、その**内容** (配列の要素数や特定の ID 命名規則など) に関する詳細なルールは表現しきれません。(これらのカスタムルールの詳細は、本ガイドラインの\*\*セクション 5「カスタム検証ルールの詳細」\*\*で解説します)。
      * *(違反時の影響例: ドキュメントの意図した構造が崩れ、ツールによる原則リストの自動生成や、特定のレイヤーのドキュメントに対する構造的な分析が正しく機能しなくなります。)*

  * **(補足) ID の一意性:**

      * ドキュメント `id` や `core_principles[].principle_id` が、リポジトリ全体やドキュメント内でユニークであることの保証も、スキーマ単体では困難であり、カスタム検証の範囲となります。
      * *(違反時の影響例: 同じIDを持つドキュメントや原則が複数存在すると、参照関係が曖昧になったり、特定の情報を一意に特定できなくなり、システム全体の整合性が崩れます。)*

**結論として、** これらの Cairns プロジェクト固有の品質基準を満たし、ドキュメント間の整合性を保つためには、JSON Schema 検証に加えて、これらのカスタムルールを網羅的にチェックする**専用の検証スクリプトが不可欠**です。

---

#### 2.1.2. CI 前の早期フィードバック

Cairns プロジェクトでは、品質保証のため、CI/CD パイプライン (例: GitHub Actions, [`devtools-list.md`](../devtools-list.md) A5 参照) において、Pull Request 作成時や main ブランチへのマージ前に、自動的に各種 Lint (YAML, Markdown) や検証 (スキーマ, カスタムルール) を実行する仕組みを導入しています。これは、リポジトリ全体の品質を維持するための**最後の砦**として機能します。

しかし、もしローカル環境で事前に検証を行わず、CI パイプラインで初めてエラーが発見された場合、以下のような非効率が発生します。

  * **フィードバックの遅延:** コードをプッシュしてから CI の実行結果がわかるまで待つ必要があり、問題の発見が遅れます。
  * **手戻りの発生:** CI でエラーが出た場合、ローカルで修正 → 再コミット → 再プッシュ → CI 再実行、という手間のかかるサイクルが発生します。
  * **コンテキストスイッチ:** 他の作業中に CI エラーの通知を受けると、修正のために思考を切り替える必要があり、集中が途切れます。
  * **CI リソースの消費:** エラーと修正の繰り返しにより、貴重な CI の実行時間を無駄に消費します。

これに対し、ローカル環境で検証を行うことで、以下のような大きなメリットが得られます。

  * **超高速フィードバックループ:** ファイルを保存した後やコミットする前に、手元のコマンド一つで**即座に**検証結果を確認でき、迅速に問題を修正できます。
  * **CI エラーの未然防止:** ローカルで問題を潰しておくことで、CI パイプラインでのエラー発生を大幅に減らすことができます。
  * **開発リズムの維持:** 面倒な手戻りが減ることで、思考の流れを止めずにスムーズに開発作業を進められます。
  * **自信の向上:** CI でエラーが出るかもしれないという不安なく、品質を確認した上で自信を持ってコードをプッシュ・共有できます。

**結論として、** ローカル検証は、単に CI の失敗を防ぐだけでなく、開発プロセス全体の効率とスピードを向上させるための**積極的な品質活動**です。CI の結果を待つのではなく、開発者自身が手元で問題を早期に発見し、解決することが強く推奨されます。

---

#### 2.1.3. DX ギャップの補完

現代の開発では、VSCode のような高機能なテキストエディタやその拡張機能が、開発者体験 (DX: Developer Experience) の向上に大きく貢献しています。リアルタイムでのエラー検出やコード補完、スタイルチェックなどは、開発の効率と快適性を高める上で非常に有用です。

Cairns プロジェクトでも、以下の VSCode 拡張機能の利用を推奨しており、これらは DX 向上に役立ちます ([`devtools-list.md`](../devtools-list.md) A7 参照)。

  * **`redhat.vscode-yaml`:** YAML の構文エラーや、JSON Schema に基づく**基本的な** Front Matter の検証 (フィールドの型、必須項目、enum 値など) をリアルタイムで検知してくれます。
  * **`DavidAnson.vscode-markdownlint`:** Markdown 本文のスタイルや構文に関するルール違反をリアルタイムで検知し、Quick Fix 機能も提供してくれるため、非常に便利です。

しかし、これらの便利な拡張機能をもってしても、Cairns プロジェクトの検証要件を**完全に**カバーすることはできません。ここには、**「DX ギャップ」** と呼ぶべき限界が存在します ([`devtools-list.md`](../devtools-list.md) A3, A7 の DX 課題・最重要課題も参照)。

  * **JSON Schema の高度な機能サポートの限界:**

      * Cairns の Front Matter スキーマは、JSON Schema Draft 2020-12 の高度な機能 (例: `$dynamicRef`) を利用しています。しかし、`redhat.vscode-yaml` をはじめとする一部の VSCode 拡張機能では、これらの最新機能が**完全にはサポートされていない**可能性があります。
      * その結果、**エディタ上ではエラーが表示されていないにも関わらず、実際にはスキーマ違反である**、という状況が発生し得ます。これは混乱を招き、DX を損なう原因となります。

  * **カスタム検証ルールの非対応:**

      * 前述 (2.1.1) の通り、Cairns プロジェクトには ID とファイル名の一致、参照整合性、時間整合性など、**プロジェクト固有のカスタム検証ルール**が多数存在します。
      * これらのカスタムルールは、**汎用的な VSCode 拡張機能では原理的にチェックすることができません**。

この DX ギャップが存在するため、開発者は**エディタのリアルタイムフィードバックだけを過信することはできません**。

そこで重要になるのが、後続セクション (2.2, 2.3) で詳しく解説する**ローカル検証スクリプト**です。このスクリプトは、まさにこの DX ギャップを埋めるために用意されています。

  * JSON Schema の**完全な**検証 (Draft 2020-12 の高度な機能を含む) を、CI 環境と同じライブラリ (例: Ajv, jsonschema) を使って実行します。
  * **全ての** Cairns 固有カスタム検証ルールを実行します。

ローカル検証スクリプトは、開発者が手元で実行できる、**プロジェクトの全ルールを網羅する、最も信頼性の高い検証手段**です。

**結論として、** ローカル検証は、IDE や拡張機能が提供するリアルタイムフィードバックの限界 (DX ギャップ) を補完し、記述した Front Matter が Cairns プロジェクトの全ての品質基準を満たしていることを開発者自身が**確実に**確認するための**必須プロセス**です。IDE の支援は最大限に活用しつつも、最終的な検証、特にコミットやプッシュ前の確認は、ローカル検証スクリプトで行う習慣をつけましょう。

---

### 2.2. 検証環境のセットアップ

このセクションでは、Cairns ドキュメントの Front Matter と本文の品質を、開発者自身のローカル環境で完全に検証するために必要な環境構築の手順を解説します。

セクション 2.1 で述べたように、Cairns プロジェクトでは JSON Schema だけでは検証しきれない独自のルールが存在し、また、CI/CD パイプラインでのエラー検出を待つよりもローカルで早期に問題を特定することが開発効率と品質向上の鍵となります。VSCode などのエディタ拡張機能は有用ですが、それだけでは検証範囲 (特にカスタムルールや最新のスキーマ機能) に限界 (DX ギャップ) があります。

ここで説明するセットアップを行うことで、CI 環境と同等の検証レベルをローカルで実現し、次セクション 2.3 で示す検証コマンドを実行できるようになります。

---

#### 2.2.1. 前提となるツール

ローカル検証スクリプトを実行するために、事前に以下のツールがご自身の開発環境にインストールされている必要があります。

  * **Node.js:**

      * カスタム検証スクリプト (JavaScript) の実行環境として使用します。
      * npm (Node Package Manager) も同時にインストールされ、依存ライブラリの管理に使用します。
      * **バージョン:** `v18.x LTS` 以降 (プロジェクト推奨バージョン。プロジェクトで特定のバージョンが要求される場合は `package.json` の `engines` フィールドを確認してください。このフィールドが設定されていると、`npm install` 時に互換性のない Node.js/npm バージョンでの実行を警告または防止します)。
      * **インストールガイド:** [Node.js 公式サイト](https://nodejs.org/) からダウンロードするか、[Volta](https://volta.sh/) や [nvm](https://github.com/nvm-sh/nvm) といったバージョンマネージャの使用を推奨します。

  * **npm (Node Package Manager):**

      * Node.js に同梱されるパッケージマネージャです。検証スクリプトが必要とする依存ライブラリ (例: `ajv`, `gray-matter`) のインストールと管理に使用します。
      * **バージョン:** Node.js に同梱されるバージョン (例: `v9.x` 以降)。
      * **インストールガイド:** Node.js と共にインストールされます。

  * **Git:**

      * Cairns プロジェクトのリポジトリをローカルにクローン (取得) し、バージョン管理を行うために必要です。
      * **バージョン:** 最新の安定版を推奨します。
      * **インストールガイド:** [Git 公式サイト](https://git-scm.com/) を参照してください。

> **注意:**
> カスタム検証スクリプトの言語選択 (Node.js or Python) は [`devtools-list.md`](../devtools-list.md) (A3, A6) に基づきます。ここでは、**Node.js が選択されたことを前提**として説明しています。もし Python が選択された場合は、Python 実行環境 (`python`) とパッケージマネージャ (`pip`) が前提ツールとなり、依存関係のインストールには `pip install -r requirements.txt` 等のコマンドが必要になります。

---

#### 2.2.2. セットアップ手順とコマンド例

検証に必要な依存ライブラリをインストールします。

1.  **リポジトリの準備と依存ライブラリのインストール**

    まず、プロジェクトの **`README.md`** に記載されている手順に従って、Cairns リポジトリをローカルにクローンし、プロジェクトのルートディレクトリに移動してください。

    次に、プロジェクトルートディレクトリで以下のコマンドを実行し、必要な依存ライブラリをインストールします。Cairns プロジェクトでは、検証スクリプトを含む開発に必要な依存ライブラリがプロジェクトルートの `package.json` ファイルに定義されています。

    ```bash
    # プロジェクトルートディレクトリで実行
    npm install
    ```

      * **補足:** このコマンドにより、開発に必要な全ての依存関係 (`dependencies` および `devDependencies`) が `node_modules` ディレクトリにインストールされます。これには、Front Matter の検証に必要なライブラリ (例: `ajv`, `gray-matter` など、通常 `devDependencies` に含まれます) も含まれます。具体的なライブラリやバージョンについては、[`devtools-list.md`](../devtools-list.md) の A3, A6 やプロジェクトの `package.json` を参照してください。カスタム検証スクリプト (例: [無効な URL を削除しました]) もこれらのライブラリを利用します。
      * **注意:** プロジェクトによっては、セットアップ手順を簡略化するために `Makefile` などでラップされたコマンド (例: `make setup` や `make install-dev`) が用意されている場合があります。その場合は、**`README.md` に記載されているセットアップ手順を優先**してください。

    このステップが完了すると、ローカル環境で検証スクリプトを実行する準備が整います。次セクション 2.3 では、実際に検証を実行する方法について解説します。

---

**(セクション 2.3. 検証の実行方法 に続く)**
